diff --git a/mm/memory.c b/mm/memory.c
index ab650c21b..9e69e45a5 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2711,7 +2711,9 @@ vm_fault_t do_swap_page(struct vm_fault *vmf)
 		goto out;
 	}
 
-
+        pr_info("swptrace %s map %lu %p\n",
+			get_current()->comm, entry.val, vmf->address);
+ 
 	delayacct_set_flag(DELAYACCT_PF_SWAPIN);
 	page = lookup_swap_cache(entry, vma, vmf->address);
 	swapcache = page;
diff --git a/mm/page-writeback.c b/mm/page-writeback.c
index 9f61dfec6..12314196a 100644
--- a/mm/page-writeback.c
+++ b/mm/page-writeback.c
@@ -2298,6 +2298,7 @@ static int __writepage(struct page *page, struct writeback_control *wbc,
 {
 	struct address_space *mapping = data;
 	int ret = mapping->a_ops->writepage(page, wbc);
+	//pr_info("swptrace %s writepage pageout %p\n",get_current()->comm, page_address(page));
 	mapping_set_error(mapping, ret);
 	return ret;
 }
diff --git a/mm/page_io.c b/mm/page_io.c
index 2e8019d0e..5a637f41b 100644
--- a/mm/page_io.c
+++ b/mm/page_io.c
@@ -26,6 +26,10 @@
 #include <linux/sched/task.h>
 #include <asm/pgtable.h>
 
+//TODO:swptrace 
+#include <linux/rmap.h>
+#include "internal.h" // vma_address
+
 static struct bio *get_swap_bio(gfp_t gfp_flags,
 				struct page *page, bio_end_io_t end_io)
 {
@@ -282,6 +286,30 @@ int __swap_writepage(struct page *page, struct writeback_control *wbc,
 	int ret;
 	struct swap_info_struct *sis = page_swap_info(page);
 
+ 	// pr_info("|swptrace|%s|out|%lu|%p\n", get_current()->comm, page_private(page), page_to_virt(page));
+
+	// TODO : throuth interverse the anon_vma_chain 
+	// figure out whether there is a node with same anon_vma
+	// mm/rmap.c page_referenced_anon
+	// anon_vma : page->mapping 
+	struct anon_vma * anon_vma; 
+	struct anon_vma_chain * avc;
+	pgoff_t pgoff_start, pgoff_end;
+
+	anon_vma = page_anon_vma(page);
+	
+
+	if (anon_vma) {
+		pgoff_start = page_to_pgoff(page);
+		pgoff_end = pgoff_start + hpage_nr_pages(page) - 1;	
+		anon_vma_interval_tree_foreach(avc, &anon_vma->rb_root, pgoff_start, pgoff_end) { 
+			struct vm_area_struct *vma = avc->vma;
+			unsigned long address = vma_address(page, vma);
+ 			pr_info("swptrace %s out %lu %p\n", get_current()->comm, page_private(page), address);
+		}
+	}
+	
+
 	VM_BUG_ON_PAGE(!PageSwapCache(page), page);
 	if (sis->flags & SWP_FS) {
 		struct kiocb kiocb;
@@ -356,6 +384,25 @@ int swap_readpage(struct page *page, bool synchronous)
 	blk_qc_t qc;
 	struct gendisk *disk;
 
+	// pr_info("|swptrace|%s|in|%lu|%p\n", get_current()->comm, page_private(page), page_to_virt(page));
+	struct anon_vma * anon_vma; 
+	struct anon_vma_chain * avc;
+	pgoff_t pgoff_start, pgoff_end;
+
+	anon_vma = page_anon_vma(page);
+	
+
+	if (anon_vma) {
+		pgoff_start = page_to_pgoff(page);
+		pgoff_end = pgoff_start + hpage_nr_pages(page) - 1;	
+		anon_vma_interval_tree_foreach(avc, &anon_vma->rb_root, pgoff_start, pgoff_end) { 
+			struct vm_area_struct *vma = avc->vma;
+			unsigned long address = vma_address(page, vma);
+ 			pr_info("swptrace %s in %lu %p\n", get_current()->comm, page_private(page), address);
+		}
+	}
+	
+
 	VM_BUG_ON_PAGE(!PageSwapCache(page) && !synchronous, page);
 	VM_BUG_ON_PAGE(!PageLocked(page), page);
 	VM_BUG_ON_PAGE(PageUptodate(page), page);
diff --git a/mm/rmap.c b/mm/rmap.c
index 76c8dfd3a..56dadb049 100644
--- a/mm/rmap.c
+++ b/mm/rmap.c
@@ -1818,6 +1818,7 @@ static void rmap_walk_anon(struct page *page, struct rmap_walk_control *rwc,
 
 	pgoff_start = page_to_pgoff(page);
 	pgoff_end = pgoff_start + hpage_nr_pages(page) - 1;
+	long depth = 0; 
 	anon_vma_interval_tree_foreach(avc, &anon_vma->rb_root,
 			pgoff_start, pgoff_end) {
 		struct vm_area_struct *vma = avc->vma;
@@ -1828,8 +1829,12 @@ static void rmap_walk_anon(struct page *page, struct rmap_walk_control *rwc,
 		if (rwc->invalid_vma && rwc->invalid_vma(vma, rwc->arg))
 			continue;
 
+		//if try_unmap_page_one() fails
 		if (!rwc->rmap_one(page, vma, address, rwc->arg))
 			break;
+		printk("swptrace %d rmap_walk %lu %p\n", depth, page_private(page), address);
+		depth++;
+		//if it is end of rwc or the page is done
 		if (rwc->done && rwc->done(page))
 			break;
 	}
